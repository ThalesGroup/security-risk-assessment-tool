/*----------------------------------------------------------------------------
*
*     Copyright Â© 2022-2025 THALES. All Rights Reserved.
*
* -----------------------------------------------------------------------------
* THALES MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
* THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
* PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THALES SHALL NOT BE
* LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
* MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*
* THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
* CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
* PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
* NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
* SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
* SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
* PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES"). THALES
* SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
* HIGH RISK ACTIVITIES.
* -----------------------------------------------------------------------------
*/

jest.mock('electron', () => ({
    dialog: { showMessageBoxSync: jest.fn() },
    BrowserWindow: { fromId: jest.fn(() => ({})) }
}), { virtual: true });

const { dialog } = require('electron');

const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
const Risk = require('../../../src/model/classes/Risk/risk');
const RiskAttackPath = require('../../../src/model/classes/Risk/risk-attack-path');

const { updateVulnerability } = require('../../../src/api/Vulnerability/handler-event');
const COLORS = require('../../../../app/src/constants/colors.js');

describe('updateVulnerability CVE score handling', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    const buildProject = () => {
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return { israProject, vulnerability };
    };

    const buildProjectWithLinkedRisk = () => {
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);

        const risk = new Risk();
        israProject.addRisk(risk);

        const riskAttackPath = new RiskAttackPath();
        risk.addRiskAttackPath(riskAttackPath);

        riskAttackPath.addVulnerability({
            vulnerabilityId: vulnerability.vulnerabilityId,
            name: vulnerability.vulnerabilityName,
            score: 7
        });

        risk.allAttackPathsScore = 9;
        risk.inherentRiskScore = 9;
        risk.mitigatedRiskScore = 5;
        risk.residualRiskScore = 4;
        riskAttackPath.attackPathScore = 6;

        return { israProject, vulnerability, risk, riskAttackPath };
    };

    test('invalid CVE score resets vulnerability and clears linked risk data', () => {
        const { israProject, vulnerability, risk } = buildProjectWithLinkedRisk();

        dialog.showMessageBoxSync.mockReturnValue(0);

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '-13');

        expect(dialog.showMessageBoxSync).toHaveBeenCalledTimes(1);
        const [, dialogPayload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(dialogPayload.title).toBe('Invalid CVE Score');
        expect(dialogPayload.message).toBe('The CVSS Score must be defined between 0 and 10 (inclusive)');

        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(result.overallLevel).toBe('None');

        const updatedRiskAttackPath = risk.getRiskAttackPath(1);
        const ref = updatedRiskAttackPath.getVulnerability(vulnerability.vulnerabilityId);
        expect(ref.score).toBeNull();
        expect(updatedRiskAttackPath.attackPathScore).toBeNull();

        expect(risk.allAttackPathsScore).toBeNull();
        expect(risk.inherentRiskScore).toBeNull();
        expect(risk.mitigatedRiskScore).toBeNull();
        expect(risk.residualRiskScore).toBeNull();
    });

    test('valid CVE score updates vulnerability and recalculates linked risk', () => {
        const { israProject, vulnerability, risk } = buildProjectWithLinkedRisk();
        // ensure inherent risk math has inputs
        risk.riskImpact.riskImpact = 3; // keep default likelihood = 3

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '7.5');

        expect(dialog.showMessageBoxSync).not.toHaveBeenCalled();
        expect(result.cveScore).toBe(7.5);
        expect(result.overallScore).toBe(8);
        expect(result.overallLevel).toBe('High');
        const expectedColorByLevel = {
            Low: COLORS.SEVERITY_COLORS.LOW,
            Medium: COLORS.SEVERITY_COLORS.MEDIUM,
            High: COLORS.SEVERITY_COLORS.HIGH,
            Critical: COLORS.SEVERITY_COLORS.CRITICAL,
        };
        expect(expectedColorByLevel[result.overallLevel]).toBe(COLORS.SEVERITY_COLORS.HIGH);

        const updatedRiskAttackPath = risk.getRiskAttackPath(1);
        const ref = updatedRiskAttackPath.getVulnerability(vulnerability.vulnerabilityId);
        expect(ref.score).toBe(8);
        expect(updatedRiskAttackPath.attackPathScore).toBe(8);
        expect(risk.allAttackPathsScore).toBe(8);

        // inherent = round((impact*5*(likelihood*5 + allPaths*2))/40)
        // = round((3*5*(3*5 + 8*2))/40) = round(465/40) = 12
        // All updates here are done from updateVulnerability call 
        expect(risk.inherentRiskScore).toBe(12);
        // default benefits/decision produce mitigated = inherent, residual = inherent
        expect(risk.mitigatedRiskScore).toBe(12);
        expect(risk.residualRiskScore).toBe(12);
    });

    test('rounding and level thresholds behave as expected', () => {
        const { israProject, vulnerability } = buildProject();

        let res;

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '0');
        expect(res.cveScore).toBe(0);
        expect(res.overallScore).toBeNull();
        expect(res.overallLevel).toBe('Low');
        const expectedColorByLevel = {
            Low: COLORS.SEVERITY_COLORS.LOW,
            Medium: COLORS.SEVERITY_COLORS.MEDIUM,
            High: COLORS.SEVERITY_COLORS.HIGH,
            Critical: COLORS.SEVERITY_COLORS.CRITICAL,
        };
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.LOW);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '3.6');
        expect(res.cveScore).toBe(3.6);
        expect(res.overallScore).toBe(4); // Math.round(3.6)
        expect(res.overallLevel).toBe('Low'); // level uses raw, <4
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.LOW);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '4');
        expect(res.cveScore).toBe(4);
        expect(res.overallScore).toBe(4);
        expect(res.overallLevel).toBe('Medium');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.MEDIUM);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '7');
        expect(res.cveScore).toBe(7);
        expect(res.overallScore).toBe(7);
        expect(res.overallLevel).toBe('High');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.HIGH);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '9');
        expect(res.cveScore).toBe(9);
        expect(res.overallScore).toBe(9);
        expect(res.overallLevel).toBe('Critical');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.CRITICAL);
    });

    test('non-numeric CVE input shows dialog and resets state', () => {
        const { israProject, vulnerability } = buildProjectWithLinkedRisk();
        dialog.showMessageBoxSync.mockReturnValue(0);

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', 'not-a-number');
        expect(dialog.showMessageBoxSync).toHaveBeenCalledTimes(1);
        const [, payload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(payload.title).toBe('Invalid CVE Score');
        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(result.overallLevel).toBe('None');
    });

});
