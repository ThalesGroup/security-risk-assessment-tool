/*----------------------------------------------------------------------------
*
*     Copyright Â© 2022-2025 THALES. All Rights Reserved.
*
* -----------------------------------------------------------------------------
* THALES MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
* THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
* PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THALES SHALL NOT BE
* LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
* MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*
* THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
* CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
* PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
* NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
* SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
* SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
* PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES"). THALES
* SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
* HIGH RISK ACTIVITIES.
* -----------------------------------------------------------------------------
*/

jest.mock('electron', () => ({
    dialog: { showMessageBoxSync: jest.fn() },
    BrowserWindow: { fromId: jest.fn(() => ({})) }
}), { virtual: true });

const { dialog } = require('electron');

const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
const Risk = require('../../../src/model/classes/Risk/risk');
const RiskAttackPath = require('../../../src/model/classes/Risk/risk-attack-path');

const { 
    addVulnerability,
    deleteVulnerability,
    updateVulnerability,
    validateVulnerabilities,
    isVulnerabilityExist,
} = require('../../../src/api/Vulnerability/handler-event');
const COLORS = require('../../../../app/src/constants/colors.js');

describe('updateVulnerability CVE score handling', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    const buildProject = () => {
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return { israProject, vulnerability };
    };

    const buildProjectWithLinkedRisk = () => {
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);

        const risk = new Risk();
        israProject.addRisk(risk);

        const riskAttackPath = new RiskAttackPath();
        risk.addRiskAttackPath(riskAttackPath);

        riskAttackPath.addVulnerability({
            vulnerabilityId: vulnerability.vulnerabilityId,
            name: vulnerability.vulnerabilityName,
            score: 7
        });

        risk.allAttackPathsScore = 9;
        risk.inherentRiskScore = 9;
        risk.mitigatedRiskScore = 5;
        risk.residualRiskScore = 4;
        riskAttackPath.attackPathScore = 6;

        return { israProject, vulnerability, risk, riskAttackPath };
    };

    test('invalid CVE score resets vulnerability and clears linked risk data', () => {
        const { israProject, vulnerability, risk } = buildProjectWithLinkedRisk();

        dialog.showMessageBoxSync.mockReturnValue(0);

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '-13');

        expect(dialog.showMessageBoxSync).toHaveBeenCalledTimes(1);
        const [, dialogPayload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(dialogPayload.title).toBe('Invalid CVE Score');
        expect(dialogPayload.message).toBe('The CVSS Score must be defined between 0 and 10 (inclusive)');

        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(result.overallLevel).toBe('None');

        const updatedRiskAttackPath = risk.getRiskAttackPath(1);
        const ref = updatedRiskAttackPath.getVulnerability(vulnerability.vulnerabilityId);
        expect(ref.score).toBeNull();
        expect(updatedRiskAttackPath.attackPathScore).toBeNull();

        expect(risk.allAttackPathsScore).toBeNull();
        expect(risk.inherentRiskScore).toBeNull();
        expect(risk.mitigatedRiskScore).toBeNull();
        expect(risk.residualRiskScore).toBeNull();
    });

    test('valid CVE score updates vulnerability and recalculates linked risk', () => {
        const { israProject, vulnerability, risk } = buildProjectWithLinkedRisk();
        // ensure inherent risk math has inputs
        risk.riskImpact.riskImpact = 3; // keep default likelihood = 3

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '7.5');

        expect(dialog.showMessageBoxSync).not.toHaveBeenCalled();
        expect(result.cveScore).toBe(7.5);
        expect(result.overallScore).toBe(8);
        expect(result.overallLevel).toBe('High');
        const expectedColorByLevel = {
            Low: COLORS.SEVERITY_COLORS.LOW,
            Medium: COLORS.SEVERITY_COLORS.MEDIUM,
            High: COLORS.SEVERITY_COLORS.HIGH,
            Critical: COLORS.SEVERITY_COLORS.CRITICAL,
        };
        expect(expectedColorByLevel[result.overallLevel]).toBe(COLORS.SEVERITY_COLORS.HIGH);

        const updatedRiskAttackPath = risk.getRiskAttackPath(1);
        const ref = updatedRiskAttackPath.getVulnerability(vulnerability.vulnerabilityId);
        expect(ref.score).toBe(8);
        expect(updatedRiskAttackPath.attackPathScore).toBe(8);
        expect(risk.allAttackPathsScore).toBe(8);

        // inherent = round((impact*5*(likelihood*5 + allPaths*2))/40)
        // = round((3*5*(3*5 + 8*2))/40) = round(465/40) = 12
        // All updates here are done from updateVulnerability call 
        expect(risk.inherentRiskScore).toBe(12);
        // default benefits/decision produce mitigated = inherent, residual = inherent
        expect(risk.mitigatedRiskScore).toBe(12);
        expect(risk.residualRiskScore).toBe(12);
    });

    test('rounding and level thresholds behave as expected', () => {
        const { israProject, vulnerability } = buildProject();

        let res;

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '0');
        expect(res.cveScore).toBe(0);
        expect(res.overallScore).toBeNull();
        expect(res.overallLevel).toBe('Low');
        const expectedColorByLevel = {
            Low: COLORS.SEVERITY_COLORS.LOW,
            Medium: COLORS.SEVERITY_COLORS.MEDIUM,
            High: COLORS.SEVERITY_COLORS.HIGH,
            Critical: COLORS.SEVERITY_COLORS.CRITICAL,
        };
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.LOW);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '3.6');
        expect(res.cveScore).toBe(3.6);
        expect(res.overallScore).toBe(4); // Math.round(3.6)
        expect(res.overallLevel).toBe('Low'); // level uses raw, <4
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.LOW);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '4');
        expect(res.cveScore).toBe(4);
        expect(res.overallScore).toBe(4);
        expect(res.overallLevel).toBe('Medium');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.MEDIUM);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '7');
        expect(res.cveScore).toBe(7);
        expect(res.overallScore).toBe(7);
        expect(res.overallLevel).toBe('High');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.HIGH);

        res = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '9');
        expect(res.cveScore).toBe(9);
        expect(res.overallScore).toBe(9);
        expect(res.overallLevel).toBe('Critical');
        expect(expectedColorByLevel[res.overallLevel]).toBe(COLORS.SEVERITY_COLORS.CRITICAL);
    });

    test('non-numeric CVE input shows dialog and resets state', () => {
        const { israProject, vulnerability } = buildProjectWithLinkedRisk();
        dialog.showMessageBoxSync.mockReturnValue(0);

        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', 'not-a-number');
        expect(dialog.showMessageBoxSync).toHaveBeenCalledTimes(1);
        const [, payload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(payload.title).toBe('Invalid CVE Score');
        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(result.overallLevel).toBe('None');
    });

});

describe('Vulnerability handler basics', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    test('addVulnerability adds a new record and returns properties array', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const israProject = new ISRAProject();

        const res = addVulnerability(israProject);
        expect(Array.isArray(res)).toBe(true);
        expect(res).toHaveLength(1);

        const projVuls = israProject.properties.Vulnerability;
        expect(projVuls).toHaveLength(1);
        expect(projVuls[0].vulnerabilityId).toBeDefined();
        expect(typeof projVuls[0].vulnerabilityId).toBe('number');
    });

    test('isVulnerabilityExist returns true for existing and false for missing', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const israProject = new ISRAProject();
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const v = new Vulnerability();
        israProject.addVulnerability(v);

        expect(isVulnerabilityExist(israProject, v.vulnerabilityId)).toBe(true);

        // delete, then existence check should be false
        israProject.deleteVulnerability(v.vulnerabilityId);
        expect(isVulnerabilityExist(israProject, v.vulnerabilityId)).toBe(false);
    });
});

describe('updateVulnerability generic fields and supporting assets', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    const setup = () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return { israProject, vulnerability };
    };

    test('addSupportingAssetRef and deleteSupportingAssetRef update the set', () => {
        const { israProject, vulnerability } = setup();

        // add
        let props = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'addSupportingAssetRef', 101);
        expect(props.supportingAssetRef).toContain(101);

        // add another
        props = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'addSupportingAssetRef', 202);
        expect(props.supportingAssetRef).toEqual(expect.arrayContaining([101, 202]));

        // delete one
        props = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'deleteSupportingAssetRef', 101);
        expect(props.supportingAssetRef).toEqual(expect.arrayContaining([202]));
        expect(props.supportingAssetRef).not.toContain(101);
    });
});

describe('deleteVulnerability cascades to risks and updates names/scores', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    const buildGraph = () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const Risk = require('../../../src/model/classes/Risk/risk');
        const RiskAttackPath = require('../../../src/model/classes/Risk/risk-attack-path');

        const israProject = new ISRAProject();

        const v1 = new Vulnerability();
        const v2 = new Vulnerability();
        v1.vulnerabilityName = 'Vul A';
        v2.vulnerabilityName = 'Vul B';
        israProject.addVulnerability(v1);
        israProject.addVulnerability(v2);

        const risk = new Risk();
        israProject.addRisk(risk);
        const path = new RiskAttackPath();
        risk.addRiskAttackPath(path);
        // Add both vulnerabilities into the path with initial scores
        path.addVulnerability({ vulnerabilityId: v1.vulnerabilityId, name: v1.vulnerabilityName, score: 8 });
        path.addVulnerability({ vulnerabilityId: v2.vulnerabilityId, name: v2.vulnerabilityName, score: 5 });

        return { israProject, v1, v2, risk, path };
    };

    test('deletes vulnerability from project; existing path refs remain (current behavior)', () => {
        const { israProject, v1, v2, risk } = buildGraph();

        deleteVulnerability(israProject, [v1.vulnerabilityId]);

        const path = risk.getRiskAttackPath(1);
        // Current implementation compares objects to ids and does not remove refs
        // Ensure the project entry is deleted
        expect(israProject.properties.Vulnerability.map(x => x.vulnerabilityId)).not.toContain(v1.vulnerabilityId);
        // But the reference on the path still exists
        expect(path.getVulnerability(v1.vulnerabilityId)).not.toBeNull();
    });

    test('delete non-referenced vulnerability does not throw and just removes from project', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const israProject = new ISRAProject();
        const v = new Vulnerability();
        israProject.addVulnerability(v);

        // Ensure present
        expect(israProject.properties.Vulnerability.map(x => x.vulnerabilityId)).toContain(v.vulnerabilityId);

        deleteVulnerability(israProject, [v.vulnerabilityId]);

        // Now removed
        expect(israProject.properties.Vulnerability.map(x => x.vulnerabilityId)).not.toContain(v.vulnerabilityId);
    });
});

describe('validateVulnerabilities updates selected fields', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    test('sets tracking, description, CVE and family', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);

        const payload = {
            vulnerabilityId: vulnerability.vulnerabilityId,
            vulnerabilityTrackingID: 'T-123',
            vulnerabilityDescription: '<p>desc</p>',
            vulnerabilityCVE: 'CVE-2024-0001',
            vulnerabilityFamily: 'Availability Vulnerability',
        };

        const res = validateVulnerabilities(israProject, payload);
        const updated = res.find(x => x.vulnerabilityId === vulnerability.vulnerabilityId);
        expect(updated.vulnerabilityTrackingID).toBe('T-123');
        expect(updated.vulnerabilityDescription).toBe('<p>desc</p>');
        expect(updated.vulnerabilityCVE).toBe('CVE-2024-0001');
        expect(updated.vulnerabilityFamily).toBe('Availability Vulnerability');
    });
});

describe('updateVulnerability name change updates attack path names', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    test('renaming vulnerability propagates to ref and recalculates names', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const Risk = require('../../../src/model/classes/Risk/risk');
        const RiskAttackPath = require('../../../src/model/classes/Risk/risk-attack-path');

        const israProject = new ISRAProject();
        const v = new Vulnerability();
        israProject.addVulnerability(v);

        const risk = new Risk();
        israProject.addRisk(risk);
        const path = new RiskAttackPath();
        risk.addRiskAttackPath(path);
        path.addVulnerability({ vulnerabilityId: v.vulnerabilityId, name: v.vulnerabilityName, score: null });

        // Change name
        const newName = 'Renamed Vul';
        const props = updateVulnerability(israProject, v.vulnerabilityId, 'vulnerabilityName', newName);
        expect(props.vulnerabilityName).toBe(newName);

        const updatedPath = risk.getRiskAttackPath(1);
        const ref = updatedPath.getVulnerability(v.vulnerabilityId);
        expect(ref.name).toBe(newName);
        // With single ref, path name equals the vulnerability name
        expect(updatedPath.attackPathName).toBe(newName);
        // All attack paths name mirrors the path name when single path exists
        expect(risk.properties.allAttackPathsName).toBe(newName);
    });
});

describe('updateVulnerability CVE input edge cases', () => {
    beforeAll(() => {
        process.env.MAIN_WINDOW_ID = '1';
    });

    beforeEach(() => {
        jest.clearAllMocks();
    });

    test('empty string CVE shows specific null message and resets', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const Risk = require('../../../src/model/classes/Risk/risk');
        const RiskAttackPath = require('../../../src/model/classes/Risk/risk-attack-path');

        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        const risk = new Risk();
        israProject.addRisk(risk);
        const path = new RiskAttackPath();
        risk.addRiskAttackPath(path);
        path.addVulnerability({ vulnerabilityId: vulnerability.vulnerabilityId, name: vulnerability.vulnerabilityName, score: 4 });

        dialog.showMessageBoxSync.mockReturnValue(0);
        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', '   ');
        expect(dialog.showMessageBoxSync).toHaveBeenCalled();
        const [, payload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(payload.message).toBe('CVE score cannot be null');
        expect(result.overallLevel).toBe('None');
        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
        expect(risk.getRiskAttackPath(1).attackPathScore).toBeNull();
    });

    test('null CVE shows specific null message and resets', () => {
        const ISRAProject = require('../../../src/model/classes/ISRAProject/isra-project');
        const Vulnerability = require('../../../src/model/classes/Vulnerability/vulnerability');
        const israProject = new ISRAProject();
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);

        dialog.showMessageBoxSync.mockReturnValue(0);
        const result = updateVulnerability(israProject, vulnerability.vulnerabilityId, 'cveScore', null);
        expect(dialog.showMessageBoxSync).toHaveBeenCalled();
        const [, payload] = dialog.showMessageBoxSync.mock.calls[0];
        expect(payload.message).toBe('CVE score cannot be null');
        expect(result.overallLevel).toBe('None');
        expect(result.cveScore).toBe(0);
        expect(result.overallScore).toBe(0);
    });
});
