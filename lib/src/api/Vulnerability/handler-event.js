/*----------------------------------------------------------------------------
*
*     Copyright Â© 2025 THALES. All Rights Reserved.
*
* -----------------------------------------------------------------------------
* THALES MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
* THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
* PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THALES SHALL NOT BE
* LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
* MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*
* THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
* CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
* PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
* NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
* SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
* SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
* PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES"). THALES
* SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
* HIGH RISK ACTIVITIES.
* -----------------------------------------------------------------------------
*/
const {
    dialog, BrowserWindow
} = require('electron');  
const { updateRiskAttackPath, calculateAttackPathName, calculateAttackPathScore, constructRiskName } = require('../Risk/handler-event');
const Vulnerability = require('../../model/classes/Vulnerability/vulnerability');

const getMainWindow = () => {
    const ID = process.env.MAIN_WINDOW_ID * 1;
    return BrowserWindow.fromId(ID);
  };

/**
  * add default risk row
  * @param {ISRAProject} israProject current ISRA Project
*/
const addVulnerability = (israProject) =>{
    try {
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return [vulnerability.properties];
    } catch (err) {
        return dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to add Vulnerability' });
    }
};

/**
  * delete selected vulnerability row(s)
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Array} ids of vulnerabilities
*/
const deleteVulnerability = (israProject, ids, win) => {
    try {
        const vulIds = []

        ids.forEach((id) => {
            vulIds.push(israProject.getVulnerability(Number(id)));
            israProject.deleteVulnerability(Number(id));
        });

        // update vulnerability evaluation refs
        const risks = israProject.properties.Risk;
        risks.forEach((risk) => {
            risk.riskAttackPaths.forEach((path)=> {
                const { riskIdRef, riskAttackPathId } = path;
                path.vulnerabilityRef.forEach((ref) => {
                    if (vulIds.includes(ref.vulnerabilityId)) {

                        deleteVulnerabilityRef(israProject, riskIdRef, riskAttackPathId, [ref.vulnerabilityId]);
                        //updateRiskAttackPath(israProject, riskIdRef, riskAttackPathId, ref.rowId, 'selectedVulnerability', '', win);
                    }
                });
            });
            constructRiskName(risk, israProject);
        });
    } catch (err) {
        console.log(err);
        dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to delete vulnerability(ies)' });
    }
};


const vulnerabilityErrorMsg = require('../../model/schema/json-schema').properties.Vulnerability.items.properties.cveScore.errorMessage;
/**
 * Parse and validate a CVE score input.
 * - Trims strings, rejects empty values
 * - Ensures numeric type and range [0, 10]
 * @param {number|string|null|undefined} rawValue user/input value for CVE score
 * @returns {number} normalized numeric CVE score within [0,10]
 * @throws {Error} when value is null/empty, non-numeric, or out of range
 */
const normalizeCveScoreInput = (rawValue) => {
    if (rawValue === null || rawValue === undefined) {
        throw new Error('CVE score cannot be null');
    }
    let candidateValue = rawValue;
    if (typeof candidateValue === 'string') {
        candidateValue = candidateValue.trim();
        if (candidateValue === '') {
            throw new Error('CVE score cannot be null');
        }
    }
    const numericValue = Number(candidateValue);
    if (Number.isNaN(numericValue)) {
        throw new Error('Invalid CVE Score');
    }
    if (numericValue < 0 || numericValue > 10) {
        throw new Error('Invalid CVE Score');
    }
    return numericValue;
};
/**
 * Map a numeric CVE score to a qualitative level.
 * Levels are derived from the raw score (not rounded):
 *  [0,4) => Low, [4,7) => Medium, [7,9) => High, [9,10] => Critical
 * @param {number} cveScore normalized numeric CVE score
 * @returns {('Low'|'Medium'|'High'|'Critical')} overall qualitative level
 */
const deriveOverallLevel = (cveScore) => {
    if (cveScore < 4) return 'Low';
    if (cveScore < 7) return 'Medium';
    if (cveScore < 9) return 'High';
    return 'Critical';
};
/**
 * Derive the integer overall score from CVE score.
 * - Rounds to nearest integer
 * - Returns null when CVE score is 0 to indicate no severity in UI aggregates
 * @param {number} cveScore normalized numeric CVE score
 * @returns {number|null} rounded integer or null when 0
 */
const deriveOverallScore = (cveScore) => (!Number(cveScore) ? null : Math.round(cveScore));
/**
 * Reset vulnerability scoring fields after invalid CVE input.
 * Sets values to safe defaults expected by the UI/renderers.
 * @param {Vulnerability} vulnerability target vulnerability instance
 */
const resetInvalidCveScoreState = (vulnerability) => {
    vulnerability.overallScore = 0;
    vulnerability.cveScore = 0;
    vulnerability.overallLevel = 'None';
};
/**
 * Propagate the CVE score to all risks/attack paths that reference the vulnerability.
 * - Updates vulnerabilityRef.score on each attack path
 * - Recalculates path/risk aggregates when score is provided
 * - Clears aggregates when score is null
 * @param {ISRAProject} israProject current project
 * @param {number} vulnerabilityId id of the updated vulnerability
 * @param {number|null} cveScore normalized numeric score or null to clear
 */
const propagateCveScoreAcrossRisks = (israProject, vulnerabilityId, cveScore) => {
    const risks = israProject.properties.Risk;
    risks.forEach((risk) => {
        const selectedRisk = israProject.getRisk(risk.riskId);
        const riskAttackPaths = selectedRisk.properties.riskAttackPaths;
        riskAttackPaths.forEach((riskAttackPath) => {
            const selectedRiskAttackPath = selectedRisk.getRiskAttackPath(riskAttackPath.riskAttackPathId);
            const ref = selectedRiskAttackPath.getVulnerability(vulnerabilityId);
            if (!ref) return;
            ref.score = cveScore === null ? null : Math.round(cveScore);
            selectedRiskAttackPath.updateVulnerability(Number(ref.vulnerabilityId), ref);
            if (cveScore === null) {
                selectedRisk.allAttackPathsScore = null;
                selectedRisk.inherentRiskScore = null;
                selectedRiskAttackPath.attackPathScore = null;
                selectedRisk.mitigatedRiskScore = null;
                selectedRisk.residualRiskScore = null;
            } else {
                calculateAttackPathScore(selectedRisk, selectedRiskAttackPath);
            }
        });
    });
};
/**
 * Validate input and assign vulnerability scoring fields.
 * @param {Vulnerability} vulnerability target vulnerability instance
 * @param {number|string|null|undefined} cveScoreInput raw input value
 * @returns {number} normalized CVE score used for propagation
 * @throws {Error} when input is invalid (null/NaN/out-of-range)
 */
const calculateOverallScore = (vulnerability, cveScoreInput) => {
    const cveScore = normalizeCveScoreInput(cveScoreInput);
    vulnerability.overallScore = deriveOverallScore(cveScore);
    vulnerability.cveScore = cveScore;
    vulnerability.overallLevel = deriveOverallLevel(cveScore);
    return cveScore;
};
/**
 * Update a vulnerability field and cascade changes when needed.
 * Special handling for:
 * - add/delete supporting asset references
 * - cveScore: validates, updates scoring fields, and propagates to risks
 * @param {ISRAProject} israProject current project
 * @param {number} id vulnerability id
 * @param {string} field field name to update
 * @param {*} value new value for the field
 * @returns {object|undefined} updated vulnerability properties or undefined on error
 */
const updateVulnerability = (israProject, id, field, value) =>{
    try {
        const vulnerability = israProject.getVulnerability(id);
        const vulnerabilityId = id;
        const vulnerabilityName = vulnerability['vulnerabilityName'];
        if (field === 'addSupportingAssetRef') vulnerability.addSupportingAssetRef(Number(value));
        else if (field === 'deleteSupportingAssetRef') vulnerability.deleteSupportingAssetRef(Number(value));
        else if (field === 'cveScore') {
            let isValidScore = false;
            try {
                const cveScore = calculateOverallScore(vulnerability, value);
                propagateCveScoreAcrossRisks(israProject, id, cveScore);
                isValidScore = true;
            } catch (err) {
                resetInvalidCveScoreState(vulnerability);
                const errorMessage = err.message === 'Invalid CVE Score' ? vulnerabilityErrorMsg : err.message;
                dialog.showMessageBoxSync(getMainWindow(), {
                    type: 'error',
                    title: 'Invalid CVE Score',
                    message: errorMessage
                });
                return vulnerability.properties;
            } finally {
                if (!isValidScore) {
                    propagateCveScoreAcrossRisks(israProject, id, null);
                }
            }
        }else vulnerability[field] = value;

        if (field === 'vulnerabilityName') {
            // update riskName
            const risks = israProject.properties.Risk;
            risks.forEach((risk) => {
                const selectedRisk = israProject.getRisk(risk.riskId);
                const riskAttackPaths = selectedRisk.properties.riskAttackPaths;
                riskAttackPaths.forEach((riskAttackPath) => {
                    const selectedRiskAttackPath = selectedRisk.getRiskAttackPath(riskAttackPath.riskAttackPathId);
                    const vulnerabilityRef = selectedRiskAttackPath.properties.vulnerabilityRef;
                    if (selectedRiskAttackPath.getVulnerability(id)) {
                        const ref = selectedRiskAttackPath.getVulnerability(id);
                        ref.name = value;
                        calculateAttackPathName(selectedRisk, selectedRiskAttackPath, israProject);

                        // Need see if need call updateVulnerability like change in score

                    }
                    /* vulnerabilityRef.forEach((ref) => {
                        if (vulnerabilityId === ref.vulnerabilityId) {
                            ref.name = value;
                            calculateAttackPathName(selectedRisk, selectedRiskAttackPath, israProject);
                        }
                    }); */
                });
            });
        } 

        return vulnerability.properties;
    } catch (err) {
        console.log(err);
        dialog.showMessageBoxSync(getMainWindow(), { type: 'error', title: 'Vulnerability Update Failed', message: `Failed to update vulnerability ${id}`});
    }
};

/**
  * validate data from Vulnerability tab
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Object} data vulnerability section data
*/
const validateVulnerabilities = (israProject, data) => {
    try {
        const { vulnerabilityId, vulnerabilityTrackingID, vulnerabilityDescription, vulnerabilityCVE, vulnerabilityFamily } = data;
        const vulnerability = israProject.getVulnerability(vulnerabilityId);
        vulnerability.vulnerabilityTrackingID = vulnerabilityTrackingID;
        vulnerability.vulnerabilityDescription = vulnerabilityDescription;
        vulnerability.vulnerabilityCVE = vulnerabilityCVE;
        vulnerability.vulnerabilityFamily = vulnerabilityFamily;

        return israProject.properties.Vulnerability;
    } catch (err) {
        console.error(err)
        dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to validate Vulnerability tab' });
    }
};

/**
  * validates if previously selected vulnerability row exists
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Integer} id vulnerability id
*/
const isVulnerabilityExist = (israProject, id) => {
    try {
        israProject.getVulnerability(id);
        return true;
    } catch (err) {
        // has been deleted in 'deleteVulnerability'
        return false;
    }
};

module.exports = {
    addVulnerability,
    deleteVulnerability,
    updateVulnerability,
    validateVulnerabilities,
    isVulnerabilityExist
};
