/*----------------------------------------------------------------------------
*
*     Copyright Â© 2022 THALES. All Rights Reserved.
 *
* -----------------------------------------------------------------------------
* THALES MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
* THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THALES SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*
* THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
* CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
* PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
* NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
* SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
* SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
* PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES"). THALES
* SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
* HIGH RISK ACTIVITIES.
* -----------------------------------------------------------------------------
*/
const {
    dialog, BrowserWindow
} = require('electron');  
const { updateRiskAttackPath, calculateAttackPathName, calculateAttackPathScore, constructRiskName } = require('../Risk/handler-event');
const Vulnerability = require('../../model/classes/Vulnerability/vulnerability');

const getMainWindow = () => {
    const ID = process.env.MAIN_WINDOW_ID * 1;
    return BrowserWindow.fromId(ID);
  };

/**
  * add default risk row
  * @param {ISRAProject} israProject current ISRA Project
*/
const addVulnerability = (israProject) =>{
    try {
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return [vulnerability.properties];
    } catch (err) {
        return dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to add Vulnerability' });
    }
};

/**
  * delete selected vulnerability row(s)
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Array} ids of vulnerabilities
*/
const deleteVulnerability = (israProject, ids, win) => {
    try {
        const vulNames = []

        ids.forEach((id) => {
            vulNames.push(israProject.getVulnerability(Number(id)));
            israProject.deleteVulnerability(Number(id));
        });

        // update vulnerability evaluation refs
        const risks = israProject.properties.Risk;
        risks.forEach((risk) => {
            risk.riskAttackPaths.forEach((path)=> {
                const { riskIdRef, riskAttackPathId } = path;
                path.vulnerabilityRef.forEach((ref) => {
                    if (vulNames.includes(ref.name)) {
                        updateRiskAttackPath(israProject, riskIdRef, riskAttackPathId, ref.rowId, 'selectedVulnerability', '', win);
                    }
                });
            });
            constructRiskName(risk, israProject);
        });
    } catch (err) {
        console.log(err);
        dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to delete vulnerability(ies)' });
    }
};


const vulnerabilityErrorMsg = require('../../model/schema/json-schema').properties.Vulnerability.items.properties.cveScore.errorMessage;
/**
  * validate data from Vulnerability tab
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Integer} id vulnerability id
  * @param {String} field vulnerability field to update
  * @param {} value value of vulnerability field
*/
const updateVulnerability = (israProject, id, field, value) =>{
    try {
        const vulnerability = israProject.getVulnerability(id);
        const vulnerabilityName = vulnerability['vulnerabilityName'];

        const calculateOverallLevel = (cveScore) => {
            if (cveScore < 4) vulnerability.overallLevel = 'Low';
            else if (cveScore >= 4 && cveScore < 7) vulnerability.overallLevel = 'Medium';
            else if (cveScore >= 7) vulnerability.overallLevel = 'High';
            
            if (cveScore < 0 || cveScore > 10) return dialog.showMessageBoxSync(getMainWindow(), { type: 'error', title: 'Invalid CVE Score', message: vulnerabilityErrorMsg });
        }

        const calculateOverallScore = (cveScore) =>{
            vulnerability.overallScore = !Number(cveScore) ? null : Math.round(cveScore);
            if(cveScore !== null) calculateOverallLevel(cveScore);
        }

        if (field === 'addSupportingAssetRef') vulnerability.addSupportingAssetRef(Number(value));
        else if (field === 'deleteSupportingAssetRef') vulnerability.deleteSupportingAssetRef(Number(value));
        else if (field === 'cveScore') {
            if (!Number(value) && value !== '0') value = null;
            vulnerability[field] = value === null ? null : Number(value);
            calculateOverallScore(value);

            //update riskAttackPath's attackPathScore
            const risks = israProject.properties.Risk;
            risks.forEach((risk) => {
                const selectedRisk = israProject.getRisk(risk.riskId);
                const riskAttackPaths = selectedRisk.properties.riskAttackPaths;
                riskAttackPaths.forEach((riskAttackPath)=> {
                    const selectedRiskAttackPath = selectedRisk.getRiskAttackPath(riskAttackPath.riskAttackPathId);
                    const vulnerabilityRef = selectedRiskAttackPath.properties.vulnerabilityRef;
                    vulnerabilityRef.forEach((ref)=> {
                        if (vulnerabilityName === ref.name) {
                            //console.log(selectedRiskAttackPath)
                            ref.score = value === null ? null : Math.round(value);
                            selectedRiskAttackPath.updateVulnerability(Number(ref.rowId), ref);
                            if(value === null){
                                selectedRisk.allAttackPathsScore = null;
                                selectedRisk.inherentRiskScore = null;
                                selectedRiskAttackPath.attackPathScore = null;
                                selectedRisk.mitigatedRiskScore = null;
                                selectedRisk.residualRiskScore = null;
                            } else calculateAttackPathScore(selectedRisk, selectedRiskAttackPath);
                        }
                    });
                });
            });
        }else vulnerability[field] = value;

        if (field === 'vulnerabilityName') {
            // update riskName
            const risks = israProject.properties.Risk;
            risks.forEach((risk) => {
                const selectedRisk = israProject.getRisk(risk.riskId);
                const riskAttackPaths = selectedRisk.properties.riskAttackPaths;
                riskAttackPaths.forEach((riskAttackPath) => {
                    const selectedRiskAttackPath = selectedRisk.getRiskAttackPath(riskAttackPath.riskAttackPathId);
                    const vulnerabilityRef = selectedRiskAttackPath.properties.vulnerabilityRef;
                    vulnerabilityRef.forEach((ref) => {
                        if (vulnerabilityName === ref.name && ref.name != '') {
                            ref.name = value;
                            calculateAttackPathName(selectedRisk, selectedRiskAttackPath, israProject);
                        }
                    });
                });
            });
        } 

        return vulnerability.properties;
    } catch (err) {
        console.log(err);
        dialog.showMessageBoxSync(getMainWindow(), { message: `Failed to update vulnerability ${id}`});
    }
};

/**
  * validate data from Vulnerability tab
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Object} data vulnerability section data
*/
const validateVulnerabilities = (israProject, data) => {
    try {
        const { vulnerabilityId, vulnerabilityTrackingID, vulnerabilityDescription, vulnerabilityCVE, vulnerabilityFamily } = data;
        const vulnerability = israProject.getVulnerability(vulnerabilityId);
        vulnerability.vulnerabilityTrackingID = vulnerabilityTrackingID;
        vulnerability.vulnerabilityDescription = vulnerabilityDescription;
        vulnerability.vulnerabilityCVE = vulnerabilityCVE;
        vulnerability.vulnerabilityFamily = vulnerabilityFamily;

        return israProject.properties.Vulnerability;
    } catch (err) {
        console.error(err)
        dialog.showMessageBoxSync(getMainWindow(), { message: 'Failed to validate Vulnerability tab' });
    }
};

/**
  * validates if previously selected vulnerability row exists
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Integer} id vulnerability id
*/
const isVulnerabilityExist = (israProject, id) => {
    try {
        israProject.getVulnerability(id);
        return true;
    } catch (err) {
        // has been deleted in 'deleteVulnerability'
        return false;
    }
};

module.exports = {
    addVulnerability,
    deleteVulnerability,
    updateVulnerability,
    validateVulnerabilities,
    isVulnerabilityExist
};