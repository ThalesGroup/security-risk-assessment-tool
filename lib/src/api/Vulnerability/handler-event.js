/*----------------------------------------------------------------------------
*
*     Copyright Â© 2022 THALES. All Rights Reserved.
 *
* -----------------------------------------------------------------------------
* THALES MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
* THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THALES SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
*
* THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
* CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
* PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
* NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
* SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
* SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
* PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES"). THALES
* SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
* HIGH RISK ACTIVITIES.
* -----------------------------------------------------------------------------
*/
const {
    dialog,
} = require('electron');  
const { updateRiskAttackPath } = require('../Risk/handler-event');
const Vulnerability = require('../../model/classes/Vulnerability/vulnerability');

/**
  * add default risk row
  * @param {ISRAProject} israProject current ISRA Project
*/
const addVulnerability = (israProject) =>{
    try {
        const vulnerability = new Vulnerability();
        israProject.addVulnerability(vulnerability);
        return [vulnerability.properties];
    } catch (err) {
        return dialog.showMessageBoxSync(null, { message: 'Failed to add Vulnerability' });
    }
};

/**
  * delete selected vulnerability row(s)
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Array} ids of vulnerabilities
*/
const deleteVulnerability = (israProject, ids, win) => {
    try {
        ids.forEach((id) => {
            israProject.deleteVulnerability(Number(id));
        });

        // update vulnerability evaluation refs
        const risks = israProject.properties.Risk;
        risks.forEach((risk) => {
            risk.riskAttackPaths.forEach((path)=> {
                const { riskIdRef, riskAttackPathId } = path;
                path.vulnerabilityRef.forEach((ref) => {
                    if (ids.includes(ref.vulnerabilityIdRef)) {
                        updateRiskAttackPath(israProject, riskIdRef, riskAttackPathId, ref.rowId, 'vulnerabilityIdRef', '', win);
                    }
                });
            })
        });
    } catch (err) {
      dialog.showMessageBoxSync(null, { message: 'Failed to delete vulnerability(ies)' });
    }
};


const vulnerabilityErrorMsg = require('../../model/schema/json-schema').properties.Vulnerability.items.properties.cveScore.errorMessage;
/**
  * validate data from Vulnerability tab
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Integer} id vulnerability id
  * @param {String} field vulnerability field to update
  * @param {} value value of vulnerability field
*/
const updateVulnerability = (israProject, id, field, value) =>{
    try {
        const vulnerability = israProject.getVulnerability(id);

        const calculateOverallLevel = (cveScore) => {
            if (cveScore < 4) vulnerability.overallLevel = 'Low';
            else if (cveScore >= 4 && cveScore < 7) vulnerability.overallLevel = 'Medium';
            else if (cveScore >= 7) vulnerability.overallLevel = 'High';
            
            if (cveScore < 0 || cveScore > 10) return dialog.showMessageBoxSync(null, { type: 'error', title: 'Invalid CVE Score', message: vulnerabilityErrorMsg });
        }

        const calculateOverallScore = (cveScore) =>{
            vulnerability.overallScore = !Number(cveScore) ? null : Math.round(cveScore);
            if(cveScore !== null) calculateOverallLevel(cveScore);
        }

        if (field === 'addSupportingAssetRef') vulnerability.addSupportingAssetRef(Number(value));
        else if (field === 'deleteSupportingAssetRef') vulnerability.deleteSupportingAssetRef(Number(value));
        else if (field === 'cveScore') {
            if (!Number(value) && value !== '0') value = null;
            vulnerability[field] = value === null ? null : Number(value);
            calculateOverallScore(value);
        }else vulnerability[field] = value;

        return vulnerability.properties;
    } catch (err) {
        dialog.showMessageBoxSync(null, { message: `Failed to update vulnerability ${id}`});
    }
};

/**
  * validate data from Vulnerability tab
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Object} data vulnerability section data
*/
const validateVulnerabilities = (israProject, data) => {
    try {
        const { vulnerabilityId, vulnerabilityTrackingID, vulnerabilityDescription, vulnerabilityCVE, vulnerabilityFamily } = data;
        const vulnerability = israProject.getVulnerability(vulnerabilityId);
        vulnerability.vulnerabilityTrackingID = vulnerabilityTrackingID;
        vulnerability.vulnerabilityDescription = vulnerabilityDescription;
        vulnerability.vulnerabilityCVE = vulnerabilityCVE;
        vulnerability.vulnerabilityFamily = vulnerabilityFamily;

        return israProject.properties.Vulnerability;
    } catch (err) {
        console.error(err)
        dialog.showMessageBoxSync(null, { message: 'Failed to validate Vulnerability tab' });
    }
};

/**
  * validates if previously selected vulnerability row exists
  * @param {ISRAProject} israProject current ISRA Project
  * @param {Integer} id vulnerability id
*/
const isVulnerabilityExist = (israProject, id) => {
    try {
        israProject.getVulnerability(id);
        return true;
    } catch (err) {
        // has been deleted in 'deleteVulnerability'
        return false;
    }
};

module.exports = {
    addVulnerability,
    deleteVulnerability,
    updateVulnerability,
    validateVulnerabilities,
    isVulnerabilityExist
};